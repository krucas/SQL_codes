### ğŸ”§ PostgreSQL procedura: `uprav_extension`

Tato procedura slouÅ¾Ã­ k ÃºpravÄ› hodnoty sloupce `extension` u zamÄ›stnance v tabulce `employees`.

#### ğŸ§  Co dÄ›lÃ¡:
- Najde zamÄ›stnance podle `employeenumber`
- Aktualizuje jeho `extension` na novou hodnotu
- VypÃ­Å¡e systÃ©movou zprÃ¡vu (`RAISE NOTICE`) s potvrzenÃ­m zmÄ›ny

#### ğŸ› ï¸ Definice:

```sql
DROP PROCEDURE IF EXISTS uprav_extension;

CREATE PROCEDURE uprav_extension(p_employeenumber INT, p_extension VARCHAR)
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE employees
    SET extension = p_extension
    WHERE employeenumber = p_employeenumber;

    RAISE NOTICE 'Zamestnanec % byl upraven, ve sloupci extension na: %', p_employeenumber, p_extension;
END;
$$;

- VolÃ¡nÃ­ procedury
CALL uprav_extension(1621, 'x101x4');



### ğŸ’° VÃ½poÄet trÅ¾eb podle produktovÃ©ho kÃ³du

Tento SQL dotaz agreguje Ãºdaje z tabulky `orderdetails`:

- Seskupuje zÃ¡znamy podle `productcode` a `priceeach`
- SÄÃ­tÃ¡ celkovÃ½ poÄet objednanÃ½ch kusÅ¯ (`quantityordered`)
- VypoÄÃ­tÃ¡ celkovÃ© trÅ¾by za kaÅ¾dÃ½ produkt jako `priceeach * quantityordered` a zaokrouhluje je na celÃ© ÄÃ­slo
- VÃ½sledek je seÅ™azen podle celkovÃ©ho poÄtu objednanÃ½ch kusÅ¯ sestupnÄ›

```sql
SELECT 
  productcode, 
  priceeach, 
  SUM(quantityordered) AS total_quantity,
  ROUND(SUM(priceeach * quantityordered)::numeric, 0) AS revenue
FROM orderdetails
GROUP BY productcode, priceeach
ORDER BY total_quantity DESC;



## ğŸ“¦ PÅ™ehled objednÃ¡vek podle stavu, produktu a mnoÅ¾stvÃ­ (vyjma doruÄenÃ½ch)

Tento SQL dotaz analyzuje objednÃ¡vky z nÄ›kolika tabulek (`orders`, `orderdetails`, `products`) a vracÃ­:

- Stav objednÃ¡vky (`o.status`)
- PoÄet vÃ½skytÅ¯ danÃ©ho stavu (`COUNT(o.status)` jako `pocet`)
- NÃ¡zev produktu (`productname`)
- PoÄet objednanÃ½ch kusÅ¯ (`quantityordered`)

#### ğŸ” Co dotaz dÄ›lÃ¡:
- PouÅ¾Ã­vÃ¡ `LEFT JOIN` mezi `orders`, `orderdetails` a `products`
- Seskupuje zÃ¡znamy podle stavu objednÃ¡vky, nÃ¡zvu produktu a poÄtu objednanÃ½ch kusÅ¯
- PomocÃ­ `HAVING` filtruje jen ty kombinace, kde:
  - Stav objednÃ¡vky nenÃ­ `'Shipped'`
  - DanÃ½ stav se vyskytuje alespoÅˆ dvakrÃ¡t (`COUNT(o.status) >= 2`)
- VÃ½sledky seÅ™azuje podle `quantityordered` sestupnÄ›, pak podle poÄtu (`pocet`) sestupnÄ›

```sql
SELECT 
  o.status, 
  COUNT(o.status) AS pocet, 
  p.productname, 
  or_de.quantityordered
FROM orders AS o
LEFT JOIN orderdetails AS or_de ON or_de.ordernumber = o.ordernumber
LEFT JOIN products AS p ON p.productcode = or_de.productcode
GROUP BY o.status, p.productname, or_de.quantityordered
HAVING o.status <> 'Shipped' AND COUNT(o.status) >= 2
ORDER BY or_de.quantityordered DESC, pocet DESC;




### ğŸ“Œ AnalÃ½za poboÄek a zamÄ›stnancÅ¯ â€“ doÄasnÃ¡ tabulka + filtrovÃ¡nÃ­ obchodnÃ­ch zÃ¡stupcÅ¯

Tato sada SQL pÅ™Ã­kazÅ¯ vyuÅ¾Ã­vÃ¡ `LEFT JOIN` pro spojenÃ­ tabulek `offices` a `employees`, 
uklÃ¡dÃ¡ vÃ½sledek do **doÄasnÃ© tabulky**, a nÃ¡slednÄ› analyzuje poÄty zamÄ›stnancÅ¯ na jednotlivÃ½ch poboÄkÃ¡ch podle pracovnÃ­ pozice.

-- ğŸ“Œ VytvoÅ™enÃ­ doÄasnÃ© tabulky s propojenÃ½mi Ãºdaji o poboÄkÃ¡ch a zamÄ›stnancÃ­ch
CREATE TEMPORARY TABLE offices_with_employees AS 
SELECT * 
FROM offices 
LEFT JOIN employees AS e
  ON e.office_code = offices.officecode;

-- ğŸ“‹ NÃ¡hled obsahu doÄasnÃ© tabulky (volitelnÃ©)
SELECT * FROM offices_with_employees;

-- ğŸ“Š VÃ½poÄet poÄtu obchodnÃ­ch zÃ¡stupcÅ¯ (Sales Rep) podle mÄ›sta a poboÄky
SELECT 
  city, 
  officecode, 
  COUNT(jobtitle) AS position, 
  jobtitle
FROM offices_with_employees
GROUP BY city, jobtitle, officecode
HAVING jobtitle = 'Sales Rep'
ORDER BY position DESC;



