### üîß PostgreSQL procedura: `uprav_extension`

Tato procedura slou≈æ√≠ k √∫pravƒõ hodnoty sloupce `extension` u zamƒõstnance v tabulce `employees`.

#### üß† Co dƒõl√°:
- Najde zamƒõstnance podle `employeenumber`
- Aktualizuje jeho `extension` na novou hodnotu
- Vyp√≠≈°e syst√©movou zpr√°vu (`RAISE NOTICE`) s potvrzen√≠m zmƒõny

#### üõ†Ô∏è Definice:

```sql
DROP PROCEDURE IF EXISTS uprav_extension;

CREATE PROCEDURE uprav_extension(p_employeenumber INT, p_extension VARCHAR)
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE employees
    SET extension = p_extension
    WHERE employeenumber = p_employeenumber;

    RAISE NOTICE 'Zamestnanec % byl upraven, ve sloupci extension na: %', p_employeenumber, p_extension;
END;
$$;

- Vol√°n√≠ procedury
CALL uprav_extension(1621, 'x101x4');



### üí∞ V√Ωpoƒçet tr≈æeb podle produktov√©ho k√≥du

Tento SQL dotaz agreguje √∫daje z tabulky `orderdetails`:

- Seskupuje z√°znamy podle `productcode` a `priceeach`
- Sƒç√≠t√° celkov√Ω poƒçet objednan√Ωch kus≈Ø (`quantityordered`)
- Vypoƒç√≠t√° celkov√© tr≈æby za ka≈æd√Ω produkt jako `priceeach * quantityordered` a zaokrouhluje je na cel√© ƒç√≠slo
- V√Ωsledek je se≈ôazen podle celkov√©ho poƒçtu objednan√Ωch kus≈Ø sestupnƒõ

```sql
SELECT 
  productcode, 
  priceeach, 
  SUM(quantityordered) AS total_quantity,
  ROUND(SUM(priceeach * quantityordered)::numeric, 0) AS revenue
FROM orderdetails
GROUP BY productcode, priceeach
ORDER BY total_quantity DESC;



## üì¶ P≈ôehled objedn√°vek podle stavu, produktu a mno≈æstv√≠ (vyjma doruƒçen√Ωch)

Tento SQL dotaz analyzuje objedn√°vky z nƒõkolika tabulek (`orders`, `orderdetails`, `products`) a vrac√≠:

- Stav objedn√°vky (`o.status`)
- Poƒçet v√Ωskyt≈Ø dan√©ho stavu (`COUNT(o.status)` jako `pocet`)
- N√°zev produktu (`productname`)
- Poƒçet objednan√Ωch kus≈Ø (`quantityordered`)

#### üîç Co dotaz dƒõl√°:
- Pou≈æ√≠v√° `LEFT JOIN` mezi `orders`, `orderdetails` a `products`
- Seskupuje z√°znamy podle stavu objedn√°vky, n√°zvu produktu a poƒçtu objednan√Ωch kus≈Ø
- Pomoc√≠ `HAVING` filtruje jen ty kombinace, kde:
  - Stav objedn√°vky nen√≠ `'Shipped'`
  - Dan√Ω stav se vyskytuje alespo≈à dvakr√°t (`COUNT(o.status) >= 2`)
- V√Ωsledky se≈ôazuje podle `quantityordered` sestupnƒõ, pak podle poƒçtu (`pocet`) sestupnƒõ

```sql
SELECT 
  o.status, 
  COUNT(o.status) AS pocet, 
  p.productname, 
  or_de.quantityordered
FROM orders AS o
LEFT JOIN orderdetails AS or_de ON or_de.ordernumber = o.ordernumber
LEFT JOIN products AS p ON p.productcode = or_de.productcode
GROUP BY o.status, p.productname, or_de.quantityordered
HAVING o.status <> 'Shipped' AND COUNT(o.status) >= 2
ORDER BY or_de.quantityordered DESC, pocet DESC;


