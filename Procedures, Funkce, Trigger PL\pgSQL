üíæ Audit log zmƒõn ƒç√°stky v tabulce amount
Tento SQL skript zav√°d√≠ mechanismus auditu zmƒõn sloupce amount v tabulce amount. C√≠lem je sledovat ka≈ædou zmƒõnu hodnoty a ukl√°dat informace o tƒõchto zmƒõn√°ch do nov√© tabulky audit_log.

üîß Co skript dƒõl√°:
Vytv√°≈ô√≠ tabulku audit_log
Uchov√°v√° z√°znamy o zmƒõn√°ch ƒç√°stky (amount) vƒçetnƒõ

CREATE TABLE audit_log (
orders_id INTEGER,
default_amount NUMERIC,
new_amount NUMERIC,
change_date TIMESTAMP DEFAULT now()
);

--ƒåist√≠ p≈ô√≠padn√© p≈ôedchoz√≠ definice triggeru a funkce
--Pomoc√≠ DROP TRIGGER a DROP FUNCTION, aby se p≈ôede≈°lo konflikt≈Øm p≈ôi opakovan√©m nasazen√≠.

DROP TRIGGER trg_castka_update ON amount;
DROP FUNCTION IF EXISTS log_update_amount;

CREATE OR REPLACE FUNCTION log_update_amount()
RETURNS TRIGGER AS $$
BEGIN
	IF NEW.amount IS DISTINCT FROM OLD.amount THEN
		INSERT INTO audit_log (orders_id, default_amount, new_amount, change_date)
		VALUES (NEW.id, OLD.amount, NEW.amount, NOW());
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;

--Vytv√°≈ô√≠ trigger a funkci
--Trigger trg_castka_update spou≈°t√≠ funkci log_update_amount() po ka≈æd√© aktualizaci ≈ô√°dku v tabulce amount.
--Funkce porovn√° starou a novou hodnotu sloupce amount. Pokud se li≈°√≠, vlo≈æ√≠ z√°znam do audit_log.

CREATE TRIGGER trg_castka_update
AFTER UPDATE ON amount
FOR EACH ROW
EXECUTE FUNCTION log_update_amount();

--P≈ô√≠klad aktualizac√≠
--Dvƒõ aktualizace, kter√© mƒõn√≠ ƒç√°stku objedn√°vky s id = 3, vygeneruj√≠ dva z√°znamy v audit_log.

UPDATE amount SET amount = amount - 17350 WHERE id = 3;
UPDATE amount SET amount = amount - 1500 WHERE id = 3;
-- v√Ωstup
3	147000	129650	"2025-06-09 16:06:50.090607"
3	129650	128150	"2025-06-09 16:06:55.815143"



### üîß PostgreSQL procedura: `uprav_extension`

Tato procedura slou≈æ√≠ k √∫pravƒõ hodnoty sloupce `extension` u zamƒõstnance v tabulce `employees`.

#### üß† Co dƒõl√°:
- Najde zamƒõstnance podle `employeenumber`
- Aktualizuje jeho `extension` na novou hodnotu
- Vyp√≠≈°e syst√©movou zpr√°vu (`RAISE NOTICE`) s potvrzen√≠m zmƒõny

#### üõ†Ô∏è Definice:

```sql
DROP PROCEDURE IF EXISTS uprav_extension;

CREATE PROCEDURE uprav_extension(p_employeenumber INT, p_extension VARCHAR)
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE employees
    SET extension = p_extension
    WHERE employeenumber = p_employeenumber;

    RAISE NOTICE 'Zamestnanec % byl upraven, ve sloupci extension na: %', p_employeenumber, p_extension;
END;
$$;

- Vol√°n√≠ procedury
CALL uprav_extension(1621, 'x101x4');




-- uk√°zka jednoduche funkce v PL/pgSQL, kter√° zjist√≠, jestli je ƒç√≠slo sud√© nebo lich√©. 
-- Na vstupu vezme INTEGER, provede podminku p≈ôes IF a vrat√≠ text. 

CREATE OR REPLACE FUNCTION suda_licha(num INTEGER)
RETURNS TEXt AS $$
DECLARE 
	vysledek TEXT;
BEGIN
	IF num % 2 = 0 THEN
		vysledek := 'cislo je sude';
	ELSE
		vysledek := 'cislo je liche';
	END if;
	RETURN vysledek;
END;
$$ LANGUAGE plpgsql;


SELECT suda_licha(98);

-- v√Ωstup "cislo je sude"

 
-- tato funkce byla  vytvo≈ôena v r√°mci uƒçen√≠ PL/pgSQL. Slou≈æ√≠ jako uk√°zka praktick√© pr√°ce s funkcemi. 
-- Skript obsahuje napsanou funkci, kter√° vrac√≠ celkov√Ω souƒçet objednan√©ho mno≈æstv√≠ jednotliv√Ωch produkt≈Ø pro zadan√© ƒç√≠slo objedn√°vky. "ordernumber".

CREATE OR REPLACE FUNCTION soucet_objednavek (order_number INTEGER)
RETURNS TABLE (
product_code VARCHAR,
celkem_objednavek NUMERIC) 
AS $$

BEGIN
	RETURN QUERY
	SELECT productcode, SUM(quantityordered)
	FROM orderdetails
	WHERE ordernumber = order_number
	GROUP BY productcode
	ORDER BY SUM(quantityordered) DESC;
END;
$$ LANGUAGE plpgsql;

-- zvol√°ni funkce
SELECT *  FROM soucet_objednavek(10122);
-- v√Ωstup 
"product_code"	"celkem_objednavek"
"S18_1889"	43
"S24_3856"	43
"S12_1099"	42
